<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>Vue3的响应式原理</h1>
  <h2>通过Proxy(代理)去代理拦截对象中的任意属性的任意变化，包括：属性的读写，属性的添加，属性的删除等</h2>
  <h2>通过Reflect(反射)：对源对象的属性进行任意操作</h2>
  <script>
    const person = { // 源对象
      name: '薛雯婷',
      age: 18
    }
    // Vue2的响应式原理
    //#region 
    // const p = {}
    // Object.defineProperty(p, 'name', {
    //   configurable: true,
    //   get () {
    //     console.log('有人读取了name属性, 我去修改页面了');
    //     return person.name
    //   },
    //   set (value) {
    //     console.log(`有人修改了name属性，修改后的值是${value}，我去修改页面了`);
    //     person.name = value
    //   }
    // })
    // Object.defineProperty(p, 'age', {
    //   configurable: true,
    //   get () {
    //     console.log('有人读取了name属性, 我去修改页面了');
    //     return person.name
    //   },
    //   set (value) {
    //     console.log(`有人修改了name属性，修改后的值是${value}，我去修改页面了`);
    //     person.name = value
    //   }
    // })
    //#endregion
    
    // Vue3的响应式原理
    // const p = new Proxy(person, {
    //   get(target, propName) {
    //     console.log(`有人读取了person的${propName}属性`);
    //     return target[propName]
    //   },
    //   set(target, propName, value) {
    //     console.log(`有人变更了person的${propName}属性，变更后的值为${value}`);
    //     target[propName] = value
    //   },
    //   defineProperty(target,propName) {
    //     console.log(`有人删除了person的${propName}属性，变更后的值为${value}`);
    //     delete target[propName]
    //   }
    // })

    // 用Reflect替代Object
    // const p = new Proxy(person, {
    //   get(target, propName) {
    //     console.log(`有人读取了person的${propName}属性`);
    //     return Reflect.get(target, propName) 
    //   },
    //   set(target, propName, value) {
    //     console.log(`有人变更了person的${propName}属性，变更后的值为${value}`);
    //     Reflect.set(target, propName, value)
    //   },
    //   defineProperty(target,propName) {
    //     console.log(`有人删除了person的${propName}属性，变更后的值为${value}`);
    //     Reflect.deleteProperty(target, propName)
    //   }
    // })
    // why用Reflect替代Object? ECMA 正逐步把Object的属性往Reflect上迁移， 比如Object.definePerproty Reflect也有对应的Reflect.definePerproty，两者有何区别
    let obj = { a: 1, b: 2 }
    // 使用Object.defineProperty拦截两遍c 会报错ERROR: Cnnot redefine property: c at Function.defineProperty (<anonymous>)
    // Object.defineProperty(obj, 'c', {
    //   get () {
    //     return 3
    //   },
    // })
    // Object.defineProperty(obj, 'c', {
    //   get () {
    //     return 4
    //   },
    // })

    // 使用 Reflect.defineProperty拦截两遍c 不会报错 且有返回值（布尔类型） 可以知晓拦截的结果正确与否
    const c1 = Reflect.defineProperty(obj, 'c', {
      get () {
        return 3
      },
    })
    const c2 = Reflect.defineProperty(obj, 'c', {
      get () {
        return 4
      },
    })
    console.log(c1, c2); // true false
  </script>
</body>
</html>